/**
 * Template Engine Bridge
 */
import { compile as render } from './template';
import { createElement } from './dom';
var HAS_ROW = /^[\n\r.]+\<tr|^\<tr/;
var HAS_SVG = /^[\n\r.]+\<svg|^\<path|^\<g/;
export var blazorTemplates = {};
export function getRandomId() {
    return '-' + Math.random().toString(36).substr(2, 5);
}
/**
 * Compile the template string into template function.
 * @param  {string} templateString - The template string which is going to convert.
 * @param  {Object} helper? - Helper functions as an object.
 * @private
 */
//tslint:disable-next-line
export function compile(templateString, helper) {
    var compiler = engineObj.compile(templateString, helper);
    //tslint:disable-next-line
    return function (data, component, propName, templateId, isStringTemplate) {
        var result = compiler(data, component, propName);
        var blazor = 'Blazor';
        var blazorTemplateId = 'BlazorTemplateId';
        if (window && window[blazor] && !isStringTemplate) {
            var randomId = getRandomId();
            if (!blazorTemplates[templateId]) {
                blazorTemplates[templateId] = [];
            }
            data[blazorTemplateId] = templateId + randomId;
            blazorTemplates[templateId].push(data);
            // tslint:disable-next-line:no-any
            return propName === 'rowTemplate' ? [createElement('tr', { id: templateId + randomId })] :
                // tslint:disable-next-line:no-any
                [createElement('div', { id: templateId + randomId })];
        }
        if (typeof result === 'string') {
            if (HAS_SVG.test(result)) {
                var ele = createElement('svg', { innerHTML: result });
                return ele.childNodes;
            }
            else {
                var ele = createElement((HAS_ROW.test(result) ? 'table' : 'div'), { innerHTML: result });
                return ele.childNodes;
            }
        }
        else {
            return result;
        }
    };
}
export function updateBlazorTemplate(templateId, templateName, comp) {
    var blazor = 'Blazor';
    if (window && window[blazor]) {
        var ejsIntrop = 'ejsInterop';
        window[ejsIntrop].updateTemplate(templateName, blazorTemplates[templateId], templateId, comp);
        blazorTemplates[templateId] = [];
    }
}
export function resetBlazorTemplate(templateId, templateName) {
    var templateDiv = document.getElementById(templateId);
    if (templateDiv) {
        // tslint:disable-next-line:no-any
        var innerTemplates = templateDiv.getElementsByClassName('blazor-inner-template');
        for (var i = 0; i < innerTemplates.length; i++) {
            var tempId = innerTemplates[i].getAttribute('data-templateId');
            var tempElement = document.getElementById(tempId);
            if (tempElement) {
                var length_1 = tempElement.children.length;
                for (var j = 0; j < length_1; j++) {
                    innerTemplates[i].appendChild(tempElement.children[0]);
                    tempElement.appendChild(innerTemplates[i].children[j].cloneNode(true));
                }
            }
        }
    }
}
/**
 * Set your custom template engine for template rendering.
 * @param  {ITemplateEngine} classObj - Class object for custom template.
 * @private
 */
export function setTemplateEngine(classObj) {
    engineObj.compile = classObj.compile;
}
/**
 * Get current template engine for template rendering.
 * @param  {ITemplateEngine} classObj - Class object for custom template.
 * @private
 */
export function getTemplateEngine() {
    return engineObj.compile;
}
//Default Engine Class
var Engine = /** @class */ (function () {
    function Engine() {
    }
    Engine.prototype.compile = function (templateString, helper) {
        if (helper === void 0) { helper = {}; }
        return render(templateString, helper);
    };
    return Engine;
}());
var engineObj = { compile: new Engine().compile };
